name: 'Repository Build Workflow'
run-name: "Repository Build: [${{ inputs.label }}]-[${{ inputs.version }}]-[${{ inputs.scope }}]"
on:
#  push:
#    branches:
#      - main
  workflow_dispatch:
    inputs:
      label:
        default: 'vendor'
        description: 'Label (e.g., vendor)'
        options:
          - 'vendor'
          - 'elseif'
          - 'custom'
        required: true
        type: choice
      version:
        default: 'latest'
        description: 'Version (e.g., 7.20; empty means latest)'
        required: false
        type: string
      scope:
        default: 'release'
        description: 'Scope (do jobs up to, inclusive)'
        options:
          - 'validate'
          - 'download'
          - 'process'
          - 'release'
        required: true
        type: choice
      download_ignore_release:
        default: false
        description: 'Download: ignore released files'
        required: false
        type: boolean
      download_ignore_branch:
        default: false
        description: 'Download: ignore branched files'
        required: false
        type: boolean
      release_tag_or_artifact:
        default: true
        description: 'Release: tag (yes) or artifact (no)'
        required: false
        type: boolean
      release_push_branch:
        default: true
        description: 'Release: push files into a branch'
        required: false
        type: boolean
      extras:
        default: '{"custom_label":"vnxme","custom_patch":"vnxme/MikroTikPatch","download_force":"false","process_force":"false","process_ignore_files":"false"}'
        description: 'JSON of additional options'
        required: false
        type: string

permissions:
  actions: write
  contents: write

env:
  app: 'app'
  box: 'box'
  tmp: 'tmp'
  TZ: 'Europe/London'

jobs:
  validate:
    runs-on: ubuntu-24.04
    outputs:
      label: ${{ steps.validate_label.outputs.label }}
      version: ${{ steps.validate_version.outputs.version }}
      matrix: ${{ steps.validate_version.outputs.matrix }}
      scope: ${{ steps.validate_scope.outputs.scope }}
      do_download: ${{ steps.validate_scope.outputs.download }}
      do_process: ${{ steps.validate_scope.outputs.process }}
      do_release: ${{ steps.validate_scope.outputs.release }}
    steps:
      - name: Validate label value
        id: validate_label
        run: |
          LABEL="$(echo "${{ inputs.label }}" | xargs)"
          if [ "${LABEL}" == 'custom' ]; then
            LABEL="$(echo "${{ fromJSON(inputs.extras).custom_label }}" | xargs)"
          fi
          if ! echo "${LABEL}" | grep -q -P '^[0-9a-zA-Z]+$'; then
            echo "::error input=label,value=${LABEL}::Invalid label value"
            exit 1
          fi
          echo "label=${LABEL}" >> "$GITHUB_OUTPUT"

      - name: Validate version value and generate matrix
        id: validate_version
        run: |
          VERSION="$(echo "${{ inputs.version }}" | xargs)"
          [ -z "${VERSION}" ] && VERSION='latest'
          
          declare -a PAIRS # format: channel|version
          readarray -d ',' -t VERSIONS < <(printf '%s' "${VERSION,,}") # converts to lower case
          for VERSION in "${VERSIONS[@]}"; do
            if echo "${VERSION}" | grep -q -P '^7\.[0-9]+(\.[0-9]+)?$'; then
              PAIRS+=("stable|${VERSION}")
            elif echo "${VERSION}" | grep -q -P '^7\.[0-9]+(\.[0-9]+)?(ab|alpha|beta|rc)[0-9]+$'; then
              PAIRS+=("testing|${VERSION}")
            else
              [ "${VERSION}" == 'latest' ] && VERSION='stable'
              if [ "${VERSION}" == 'stable' ] || [ "${VERSION}" == 'testing' ]; then
                FILE="latest_${VERSION}.txt"
                URL="https://download.mikrotik.com/routeros/NEWESTa7.${VERSION}"
                wget -nv -t 3 -O "${FILE}" "${URL}" || rm -f "${FILE}"
                if [ ! -f "${FILE}" ]; then
                  echo "::error::Failed to get the latest version for the ${VERSION} channel"
                  exit 1
                fi
                LATEST="$(cat "${FILE}" | cut -d ' ' -f1)" && rm -f "${FILE}"
                PAIRS+=("${VERSION}|${LATEST}")
              else
                echo "::error input=version,value=${VERSION}::Invalid version value"
                exit 1
              fi
            fi
          done
          
          JSON=""
          unset VERSIONS; declare -a VERSIONS
          mapfile -t PAIRS < <(printf '%s\n' "${PAIRS[@]}" | sort -u)
          for PAIR in "${PAIRS[@]}"; do
            CHANNEL="$(echo "${PAIR}" | cut -d '|' -f1)"
            VERSION="$(echo "${PAIR}" | cut -d '|' -f2)"
            [ ${#JSON} -ne 0 ] && JSON="${JSON},"
            JSON="${JSON}{\"channel\":\"${CHANNEL}\",\"version\":\"${VERSION}\"}"
            VERSIONS+=("${VERSION}")
          done
          JSON="[${JSON}]"
          printf -v VERSION '%s,' "${VERSIONS[@]}"
          echo "matrix=${JSON}" >> "$GITHUB_OUTPUT"
          echo "version=${VERSION%,}" >> "$GITHUB_OUTPUT"

      - name: Validate scope value
        id: validate_scope
        run: |
          SCOPE="$(echo "${{ inputs.scope }}" | xargs)"
          if [ "${SCOPE}" == "validate" ]; then
            DOWNLOAD=false
            PROCESS=false
            RELEASE=false
          elif [ "${SCOPE}" == "download" ]; then
            DOWNLOAD=true
            PROCESS=false
            RELEASE=false
          elif [ "${SCOPE}" == "process" ]; then
            DOWNLOAD=true
            PROCESS=true
            RELEASE=false
          elif [ "${SCOPE}" == "release" ]; then
            DOWNLOAD=true
            PROCESS=true
            RELEASE=true
          else
            echo "::error input=scope,value=${SCOPE}::Invalid scope value"
            exit 1
          fi
          {
            echo "scope=${SCOPE}"
            echo "download=${DOWNLOAD}"
            echo "process=${PROCESS}"
            echo "release=${RELEASE}"
          } >> "$GITHUB_OUTPUT"

      - name: Compose a step summary
        id: compose_summary
        run: |
          {
            echo "### Outputs"
            echo "- label: \`${{ steps.validate_label.outputs.label }}\`"
            echo "- version: \`${{ steps.validate_version.outputs.version }}\`"
            echo "- matrix: \`${{ steps.validate_version.outputs.matrix }}\`"
            echo "- scope: \`${{ steps.validate_scope.outputs.scope }}\`"
            echo "- do_download: \`${{ steps.validate_scope.outputs.download }}\`"
            echo "- do_process: \`${{ steps.validate_scope.outputs.process }}\`"
            echo "- do_release: \`${{ steps.validate_scope.outputs.release }}\`"
            echo "- download_ignore_release: \`${{ inputs.download_ignore_release }}\`"
            echo "- download_ignore_branch: \`${{ inputs.download_ignore_branch }}\`"
            echo "- extras: \`${{ inputs.extras }}\`"
          } >> "$GITHUB_STEP_SUMMARY"

  download:
    needs: validate
    if: needs.validate.outputs.do_download == 'true'
    strategy:
      matrix:
        include: ${{ fromJSON(needs.validate.outputs.matrix) }}
    runs-on: ubuntu-24.04
    env:
      dkey: "${{ needs.validate.outputs.label }}-${{ matrix.version }}-download"
    steps:
      - name: Look up downloaded files in cache
        id: lookup
        uses: actions/cache/restore@v4
        with:
          key: "${{ env.dkey }}"
          lookup-only: true
          path:
            "${{ env.tmp }}/${{ env.dkey }}.tar.zst"

      - name: Make '${{ env.app }}', '${{ env.box }}' and '${{ env.tmp }}' directories
        id: make_dirs
        if: ${{ fromJSON(inputs.extras).download_force == 'true' || steps.lookup.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p {"${{ env.app }}","${{ env.box }}","${{ env.tmp }}"}

      - name: Checkout 'main' branch into '${{ env.app }}' directory
        id: checkout_repository
        if: ${{ fromJSON(inputs.extras).download_force == 'true' || steps.lookup.outputs.cache-hit != 'true' }}
        uses: actions/checkout@v5
        with:
          path: "${{ env.app }}"

      - name: Download files from release, branch or vendor into '${{ env.box }}' directory
        id: download_files
        if: ${{ fromJSON(inputs.extras).download_force == 'true' || steps.lookup.outputs.cache-hit != 'true' }}
        env:
          label: "${{ needs.validate.outputs.label }}"
        run: |
          CMD="sudo '${{ env.app }}/download.sh' -d '${{ env.box }}' -l '${{ env.label }}' -v '${{ matrix.version }}'"
          [ "${{ inputs.download_ignore_release }}" == 'true' ] && CMD="${CMD} --ignore-release"
          [ "${{ inputs.download_ignore_branch }}" == 'true' ] && CMD="${CMD} --ignore-branch"
          [ "${{ needs.validate.outputs.label }}" == 'elseif' ] && CMD="${CMD} --patch elseif/MikroTikPatch"
          [ "${{ inputs.label }}" == 'custom' ] && CMD="${CMD} --patch ${{ fromJSON(inputs.extras).custom_patch }}"
          eval "${CMD}"

      - name: Create an archive in '${{ env.tmp }}' directory with downloaded files in '${{ env.box }}' directory
        id: create_archive
        if: ${{ fromJSON(inputs.extras).download_force == 'true' || steps.lookup.outputs.cache-hit != 'true' }}
        run: |
          FILE="${{ env.tmp }}/${{ env.dkey }}.tar.zst"
          (cd -- "${{ env.box }}" || true; sudo find -- * .*) | sudo tar --zst -cf "${FILE}" -C "${{ env.box }}" -T -
          sudo chown "$(id -un)":"$(id -gn)" "${FILE}"

      - name: Delete downloaded files from cache
        id: delete_cache
        if: ${{ fromJSON(inputs.extras).download_force == 'true' && steps.lookup.outputs.cache-hit == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh api --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/caches?key=${{ env.dkey }}&ref=${{ github.ref }}"

      - name: Save downloaded files from '${{ env.box }}' directory to cache
        id: save_cache
        if: ${{ fromJSON(inputs.extras).download_force == 'true' || steps.lookup.outputs.cache-hit != 'true' }}
        uses: actions/cache/save@v4
        with:
          key: "${{ env.dkey }}"
          path: 
            "${{ env.tmp }}/${{ env.dkey }}.tar.zst"

  process:
    needs:
      - validate
      - download
    if: needs.validate.outputs.do_process == 'true'
    strategy:
      matrix:
        include: ${{ fromJSON(needs.validate.outputs.matrix) }}
    runs-on: ubuntu-24.04
    env:
      dkey: "${{ needs.validate.outputs.label }}-${{ matrix.version }}-download"
      pkey: "${{ needs.validate.outputs.label }}-${{ matrix.version }}-process"
    steps:
      - name: Look up processed files in cache
        id: lookup_processed
        uses: actions/cache/restore@v4
        with:
          key: "${{ env.pkey }}"
          lookup-only: 'true'
          path:
            "${{ env.tmp }}/${{ env.pkey }}.tar.zst"

      - name: Make '${{ env.app }}', '${{ env.box }}' and '${{ env.tmp }}' directories
        id: make_dirs
        if: ${{ fromJSON(inputs.extras).process_force == 'true' || steps.lookup_processed.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p {"${{ env.app }}","${{ env.box }}","${{ env.tmp }}"}

      - name: Restore an archive with downloaded files from cache into '${{ env.tmp }}' directory
        id: restore_downloaded
        if: ${{ fromJSON(inputs.extras).process_force == 'true' || steps.lookup_processed.outputs.cache-hit != 'true' }}
        uses: actions/cache/restore@v4
        with:
          key: "${{ env.dkey }}"
          path:
            "${{ env.tmp }}/${{ env.dkey }}.tar.zst"

      - name: Unpack downloaded files into '${{ env.box }}' directory
        id: unpack_archive
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' }}
        run: |
          FILE="${{ env.tmp }}/${{ env.dkey }}.tar.zst"
          sudo tar --zst -xf "${FILE}" -C "${{ env.box }}" && rm -f "${FILE}"

      - name: Checkout 'main' branch into '${{ env.app }}' directory
        id: checkout_repository
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' }}
        uses: actions/checkout@v5
        with:
          path: "${{ env.app }}"

      - name: Install required binaries leveraging cache
        id: install_binaries
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' }}
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          execute_install_scripts: true
          packages: binutils-common binwalk bzip2 device-tree-compiler genisoimage gzip lz4 lzma lzop qemu-utils rsync xz-utils zip zstd
          version: 1.0

      - name: Install required Python packages
        id: install_packages
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' }}
        run: |
          sudo pip install -r "${{ env.app }}/requirements.txt"

      - name: Process files in '${{ env.box }}' directory
        id: process_files
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' }}
        run: |
          if [ " ${{ fromJson(inputs.extras).process_ignore_files }}" != "true" ]; then
            sudo "${{ env.app }}/process.sh" "${{ env.box }}"
          fi

      - name: Create an archive in '${{ env.tmp }}' directory with processed files in '${{ env.box }}' directory
        id: create_archive
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' }}
        run: |
          FILE="${{ env.tmp }}/${{ env.pkey }}.tar.zst"
          (cd -- "${{ env.box }}" || true; sudo find -- * .*) | sudo tar --zst -cf "${FILE}" --exclude='downloads.txt' -X "${{ env.box }}/downloads.txt" -C "${{ env.box }}" -T -
          sudo chown "$(id -un)":"$(id -gn)" "${FILE}"

      - name: Delete processed files from cache
        id: delete_cache
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.lookup_processed.outputs.cache-hit == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh api --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/caches?key=${{ env.pkey }}&ref=${{ github.ref }}"

      - name: Save processed files from '${{ env.box }}' directory to cache
        id: save_cache
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' }}
        uses: actions/cache/save@v4
        with:
          key: "${{ env.pkey }}"
          path:
            "${{ env.tmp }}/${{ env.pkey }}.tar.zst"

  release:
    needs:
      - validate
      - download
      - process
    if: needs.validate.outputs.do_release == 'true'
    strategy:
      matrix:
        include: ${{ fromJSON(needs.validate.outputs.matrix) }}
    runs-on: ubuntu-24.04
    env:
      branch: "${{ needs.validate.outputs.label }}-${{ matrix.version }}"
      dkey: "${{ needs.validate.outputs.label }}-${{ matrix.version }}-download"
      pkey: "${{ needs.validate.outputs.label }}-${{ matrix.version }}-process"
      tag: "v${{ matrix.version }}-${{ needs.validate.outputs.label }}"
    steps:
      - name: Make '${{ env.app }}', '${{ env.box }}' and '${{ env.tmp }}' directories
        id: make_dirs
        run: |
          mkdir -p {"${{ env.app }}","${{ env.box }}","${{ env.tmp }}"}

      - name: Checkout 'main' branch into '${{ env.box }}' directory
        id: checkout_repository
        uses: actions/checkout@v5
        with:
          path: "${{ env.box }}"

      - name: Copy files from '${{ env.box }}' directory to '${{ env.app }}' directory
        id: copy_files
        run: |
          cp -r "${{ env.box }}"/* "${{ env.app }}"/

#      - name: Checkout '${{ env.branch }}' branch into '${{ env.box }}' directory
#        id: checkout_repository
#        uses: actions/checkout@v5
#        with:
#          path: "${{ env.box }}"
#          ref: "${{ env.branch }}"

      - name: Switch 'main' branch to '${{ env.branch }}' branch
        id: switch_branch
        run: |
          cd "${{ env.box }}" && git switch --orphan "${{ env.branch }}"

      - name: Restore an archive with downloaded files from cache into '${{ env.tmp }}' directory
        id: restore_downloaded
        uses: actions/cache/restore@v4
        with:
          key: "${{ env.dkey }}"
          path:
            "${{ env.tmp }}/${{ env.dkey }}.tar.zst"

      - name: Restore an archive with processed files from cache into '${{ env.tmp }}' directory
        id: restore_processed
        uses: actions/cache/restore@v4
        with:
          key: "${{ env.pkey }}"
          path:
            "${{ env.tmp }}/${{ env.pkey }}.tar.zst"

      - name: Extract archives with downloaded and processed files into '${{ env.box }}' directory
        id: extract_archives
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' }}
        run: |
          FILE="${{ env.tmp }}/${{ env.dkey }}.tar.zst"
          sudo tar --zst -xf "${FILE}" -C "${{ env.box }}" && rm -f "${FILE}"
          
          FILE="${{ env.tmp }}/${{ env.pkey }}.tar.zst"
          sudo tar --zst -xf "${FILE}" -C "${{ env.box }}" && rm -f "${FILE}"

      - name: Create release files
        id: create_release
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' }}
        run: |
          EXCL='exclusions.txt'
          cd -- "${{ env.box }}" && { sudo find -- * -type f -size +32M | sort | sudo tee "${EXCL}" || true; } && cd - > /dev/null
          
          LIST="${{ env.tmp }}/files.txt"
          { cd -- "${{ env.box }}" || true; sudo find -- * .*; cd - > /dev/null; } > "${LIST}"
          
          FILE="${{ env.tmp }}/routeros-${{ env.branch }}-full.tar.zst"
          sudo tar --zst -cf "${FILE}" --owner=0 --group=0 --exclude='.git' --exclude="${EXCL}" -C "${{ env.box }}" -T "${LIST}"
          du -h "${FILE}"
          
          FILE="${{ env.tmp }}/routeros-${{ env.branch }}-light.tar.zst"
          sudo tar --zst -cf "${FILE}" --owner=0 --group=0 --exclude='.git' -X "${{ env.box }}/${EXCL}" -C "${{ env.box }}" -T "${LIST}"
          du -h "${FILE}"
          
          rm -- "${LIST}"

      - name: Delete duplicate release and tag
        id: delete_release
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' && inputs.release_tag_or_artifact }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          FOUND='true'
          ID="$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/releases/tags/${{ env.tag }}" \
            --jq '.id')" || FOUND='false'
          if [ -n "${ID}" ] && [ "${FOUND}" == 'true' ]; then
            gh api --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/${{ github.repository }}/releases/${ID}" || echo 'warning: Failed to delete an existing release'
          fi
          
          FOUND='true'
          REF="$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/git/ref/tags/${{ env.tag }}" \
            --jq '.ref')" || FOUND='false'
          if [ -n "${REF}" ] && [ "${FOUND}" == 'true' ]; then
            gh api --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/${{ github.repository }}/git/refs/tags/${{ env.tag }}" || echo 'warning: Failed to delete an existing tag'
          fi
          
          if [ "${{ needs.validate.outputs.label }}" == 'vendor' ] && [ "${{ matrix.channel }}" == 'stable' ]; then 
            TAGS="$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/${{ github.repository }}/git/matching-refs/tags/" \
              --jq '.[].ref' 2>/dev/null || true)"
            LATEST="$({ echo "${TAGS}" | cut -d '/' -f 3 | grep -P "^v7\.[0-9]+(\.[0-9]+)?-${{ needs.validate.outputs.label }}$"; echo "${{ env.tag }}"; } | sort -V | tail -1)"
            if [ "${LATEST}" == "${{ env.tag }}" ]; then
              echo "latest=true" >> "$GITHUB_OUTPUT"
            else
              echo "latest=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "latest=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Compose a release description
        id: compose_description
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' && inputs.release_tag_or_artifact }}
        run: |
          SHA_MSG="$(cd "${{ env.box }}" && git log -1 --pretty=%B "${{ github.sha }}" | head -1)"
          {
            #echo 'description<<EOF'
            echo -e "Automatic release ([${SHA_MSG}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})):"
            echo -e "- Run https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/attempts/${{ github.run_attempt }}"
            echo -e "- Job https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/job/${{ job.check_run_id }}"
            echo -e "- Tree https://github.com/${{ github.repository }}/tree/${{ env.branch }}"
            echo -e "\n"
            cat "${{ env.box }}/changelog.txt"
            #echo EOF
          } > "${{ env.tmp }}/description.txt"

      - name: Upload release files as attachments
        id: upload_attachments
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' && inputs.release_tag_or_artifact }}
        uses: softprops/action-gh-release@v2
        with:
          name: "RouterOS ${{ matrix.version }} by ${{ needs.validate.outputs.label }}"
          body_path: "${{ env.tmp }}/description.txt"
          tag_name: "${{ env.tag }}"
          make_latest:  ${{ steps.delete_release.outputs.latest == 'true' }}
          prerelease:  ${{ needs.validate.outputs.label == 'vendor' && matrix.channel == 'testing' }}
          files: |
            ${{ env.tmp }}/*.tar.zst

      - name: Upload release files as artifacts
        id: upload_artifacts
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' && !inputs.release_tag_or_artifact }}
        uses: actions/upload-artifact@v4
        with:
          compression-level: 0
          name: "${{ env.branch }}"
          path: |
            ${{ env.tmp }}/*

      - name: Normalize files
        id: normalize_files
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' && inputs.release_push_branch }}
        run: |
          sudo "${{ env.app }}/normalize.sh" "${{ env.box }}"
          sudo chown -hR "$(id -un)":"$(id -gn)" "${{ env.box }}"
          cd -- "${{ env.box }}" || true
          find -- * -type f -o -type d \! -readable -exec bash -c 'echo "warning: {} is still not readable"' \;
          {
            echo '# This branch contains an unpacked routeros-...-light.tar.zst archive.'
            echo '# Unlike routeros-...-full.tar.zst, it excludes relatively large files.'
            echo '#'
            echo '# The following files have been excluded because their size exceeds 32MB.'
            cat 'exclusions.txt'
            echo '#'
            echo '# Block and character devices, pipes and sockets cannot be committed by git,'
            echo '# so they are only present in the archives mentioned above.'
          } > '.gitignore'
          cd - || true

      - name: Compose a commit message
        id: compose_message
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' && inputs.release_push_branch }}
        run: |
          SHA_MSG="$(cd "${{ env.box }}" && git log -1 --pretty=%B "${{ github.sha }}" | head -1)"
          {
            echo 'message<<EOF'
            echo -e "Automatic commit (${SHA_MSG})\n"
            echo -e "App https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
            echo -e "Run https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/attempts/${{ github.run_attempt }}"
            echo -e "Job https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/job/${{ job.check_run_id }}"
            echo -e "Tag https://github.com/${{ github.repository }}/releases/tag/${{ env.tag }}"
            echo EOF
          } >> "$GITHUB_OUTPUT"

      - name: Add files, commit and push
        id: push_files
        if: ${{ steps.restore_downloaded.outputs.cache-hit == 'true' && steps.restore_processed.outputs.cache-hit == 'true' && inputs.release_push_branch }}
        uses: stefanzweifel/git-auto-commit-action@v6
        with:
          branch: ${{ env.branch }}
          commit_message: ${{ steps.compose_message.outputs.message }}
          push_options: '--force'
          repository: "${{ env.box }}"
          #tagging_message: "${{ env.tag }}"

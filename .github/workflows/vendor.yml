name: Vendor RouterOS 7.x Internals Workflow
on:
#  push:
#    branches:
#      - main
  workflow_dispatch:
    inputs:
      prefix:
        description: "Prefix (e.g., vendor)"
        required: true
        default: 'vendor'
        type: string
      host:
        description: "Host (e.g., dl.example.com)"
        required: true
        default: 'download.mikrotik.com'
        type: string
      channel:
        description: 'Channel (e.g., stable)'
        required: true
        default: 'stable'
        type: choice
        options:
          - 'stable'
          - 'testing'
          - 'stable,testing'
      version:
        description: "Version (e.g., 7.19.4; empty for latest)"
        required: false
        default: ''
        type: string
      read_cache:
        description: "Read files from cache"
        required: false
        default: true
        type: boolean
      write_cache:
        description: "Write files to cache"
        required: false
        default: true
        type: boolean

permissions:
  contents: write

env:
  TZ: 'Europe/London'

jobs:
  validate:
    runs-on: ubuntu-24.04
    outputs:
      prefix: ${{ inputs.prefix }}
      host: ${{ inputs.host }}
      channel: ${{ steps.convert_channel.outputs.JSON }}
      version: ${{ inputs.version }}
    steps:
      - name: Validate prefix value
        run: |
          if [[ ! "${{ inputs.prefix }}" =~ ^[0-9a-zA-Z]+$ ]]; then
            echo "::error input=prefix,value=${{ inputs.prefix }}::Invalid prefix value"
            exit 1
          fi
      - name: Validate host value
        run: |
          if [[ -z "$(echo "${{ inputs.host }}" | grep -P '(?=^.{1,254}$)(^(?>(?!\d+\.)[a-zA-Z0-9_\-]{1,63}\.?)+(?:[a-zA-Z]{2,})$)')" ]]; then
            echo "::error input=host,value=${{ inputs.host }}::Invalid host value"
            exit 1
          fi
      - name: Validate version value
        run: |
          if [[ -n "${{ inputs.version }}" ]]; then
            if [[ "${{ inputs.channel }}" == *","* ]]; then
              echo "::error input=version,value=${{ inputs.version }}::Same version value can't apply to multiple channels"
              exit 1
            fi
            if [[ "${{ inputs.channel }}" == "stable" ]]; then
              if [[ ! "${{ inputs.version }}" =~ ^7\.\d+(?:\.\d+)?$ ]]; then
                echo "::error input=version,value=${{ inputs.version }}::Invalid version value for the stable channel"
                exit 1
              fi
            fi
            if [[ "${{ inputs.channel }}" == "testing" ]]; then
              if [[ ! "${{ inputs.version }}" =~ ^7\.\d+(?:\.\d+)?(?:alpha|beta|rc)\d+$ ]]; then
                echo "::error input=version,value=${{ inputs.version }}::Invalid version value for the testing channel"
                exit 1
              fi
            fi
          fi
      - name: Convert channel value into JSON
        id: convert_channel
        run: |
          LIST="${{ inputs.channel }}"
          echo "JSON=[\"${LIST//,/\",\"}\"]" >> $GITHUB_OUTPUT
  download:
    needs: validate
    runs-on: ubuntu-24.04
    outputs:
      version: ${{ steps.refine_version.outputs.VERSION }}
    strategy:
      matrix:
        channel: ${{ fromJSON(needs.validate.outputs.channel) }}
    steps:
      - name: Refine version value
        id: refine_version
        run: |
          VERSION="${{ needs.validate.outputs.version }}"
          if [[ -z "${VERSION}" ]]; then
            VERSION_URL="https://${{ needs.validate.outputs.host }}/routeros/NEWESTa7.${{ matrix.channel }}"
            echo "::debug::VERSION_URL=${VERSION_URL}"
            VERSION=$(wget -nv -O - ${VERSION_URL} | cut -d ' ' -f1)
            echo "::debug::VERSION=${VERSION}"
          fi
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT

      - name: Cache files
        id: cache_files
        uses: actions/cache@v4
        with:
          key: ${{ needs.validate.outputs.prefix }}-${{ matrix.channel }}-${{ steps.refine_version.outputs.VERSION }}
          lookup-only: true
          path: |
            changelog.txt
            arm
            arm64
            mipsbe
            mmips
            ppc
            smips
            tile
            x86

      - name: Get a changelog
        if: steps.cache_files.outputs.cache-hit != 'true'
        run: |
          CHANGELOG_URL="https://${{ needs.validate.outputs.host }}/routeros/${{ steps.refine_version.outputs.VERSION }}/CHANGELOG"
          echo "::debug::CHANGELOG_URL=${CHANGELOG_URL}"
          wget -nv -O changelog.txt ${CHANGELOG_URL}

      - name: Download files
        if: steps.cache_files.outputs.cache-hit != 'true'
        run: |
          ARHCS=(arm arm64 mipsbe mmips ppc smips tile x86)
          HOST="${{ needs.validate.outputs.host }}"
          PACKAGES=(routeros calea container dude extra-nic gps iot iot-bt-extra lora rose-storage switch-marvell tr069-client ups user-manager wifi-mediatek wifi-qcom wifi-qcom-ac wireless zerotier)
          VERSION="${{ steps.refine_version.outputs.VERSION }}"
          for ARCH in ${ARHCS[@]}; do
            mkdir -p ${ARCH}
            [ "${ARCH}" == 'x86' ] && SUFFIX='' || SUFFIX="-${ARCH}"
            if [ "${ARCH}" == 'x86' ] || [ "${ARCH}" == 'arm64' ]; then
              IMG_FILE="${ARCH}/chr-${VERSION}${SUFFIX}.img.zip"
              IMG_URL="https://${HOST}/routeros/${VERSION}/chr-${VERSION}${SUFFIX}.img.zip"
              wget -nv -O ${IMG_FILE} ${IMG_URL} || rm -f ${IMG_FILE}
              ISO_FILE="${ARCH}/mikrotik-${VERSION}${SUFFIX}.iso"
              ISO_URL="https://${HOST}/routeros/${VERSION}/mikrotik-${VERSION}${SUFFIX}.iso"
              wget -nv -O ${ISO_FILE} ${ISO_URL} || rm -f ${ISO_FILE}
              if [ "${ARCH}" == 'x86' ]; then
                IMG_FILE="${ARCH}/install-image-${VERSION}${SUFFIX}.img.zip"
                IMG_URL="https://${HOST}/routeros/${VERSION}/install-image-${VERSION}${SUFFIX}.zip"
                wget -nv -O ${IMG_FILE} ${IMG_URL} || rm -f ${IMG_FILE}
                TGZ_FILE="${ARCH}/netinstall-cli-${VERSION}${SUFFIX}.tar.gz"
                TGZ_URL="https://${HOST}/routeros/${VERSION}/netinstall-${VERSION}${SUFFIX}.tar.gz"
                wget -nv -O ${TGZ_FILE} ${TGZ_URL} || rm -f ${TGZ_FILE}
                W32_FILE="${ARCH}/netinstall-w32-${VERSION}${SUFFIX}.exe.zip"
                W32_URL="https://${HOST}/routeros/${VERSION}/netinstall-${VERSION}${SUFFIX}.zip"
                wget -nv -O ${W32_FILE} ${W32_URL} || rm -f ${W32_FILE}
                W64_FILE="${ARCH}/netinstall-w64-${VERSION}${SUFFIX}.exe.zip"
                W64_URL="https://${HOST}/routeros/${VERSION}/netinstall64-${VERSION}${SUFFIX}.zip"
                wget -nv -O ${W64_FILE} ${W64_URL} || rm -f ${W64_FILE}
              fi
            fi
            for PACKAGE in ${PACKAGES[@]}; do
              FILE="${ARCH}/${PACKAGE}-${VERSION}${SUFFIX}.npk"
              URL="https://${HOST}/routeros/${VERSION}/${PACKAGE}-${VERSION}${SUFFIX}.npk"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            done
          done

  obtain_internals:
    needs:
      - validate
      - download
    runs-on: ubuntu-24.04
    strategy:
      matrix:
        channel: ${{ fromJSON(needs.validate.outputs.channel) }}
    steps:
      - name: Install requirements leveraging cache
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          execute_install_scripts: true
          packages: binutils-common binwalk bzip2 device-tree-compiler genisoimage gzip lz4 lzma lzop qemu-utils rsync xz-utils zip zstd
          version: 1.0

      #- name: Install requirements
      #  run: |
      #    echo $(uname -a)
      #    sudo apt update > /dev/null
      #    sudo apt install -y binutils-common binwalk bzip2 genisoimage gzip lz4 lzma lzop rsync xz-utils zip zstd
      #    #sudo apt install -y dosfstools extlinux mkisofs qemu-utils xorriso > /dev/null
      #    #sudo modprobe nbd > /dev/null

      #- name: Install Python
      #  uses: actions/setup-python@v5
      #  with:
      #    python-version: '3.11'

      - name: Checkout the repository
        uses: actions/checkout@v4

      - name: Prepare scripts
        run: |
          wget -nv -O /tmp/extract-vmlinux.sh "https://raw.githubusercontent.com/torvalds/linux/master/scripts/extract-vmlinux" || true
          cp -r ./tools /tmp/
          cp ./*.py /tmp/
          cp ./*.sh /tmp/
          chmod +x /tmp/*.sh        

      - name: Prepare an empty branch
        id: prepare_branch
        run: |
          BRANCH="${{ needs.validate.outputs.prefix }}-${{ matrix.channel }}-${{ needs.download.outputs.version }}"
          echo "BRANCH=${BRANCH}" >> $GITHUB_ENV
          git switch --orphan ${BRANCH}

      - name: Cache files
        id: cache_files
        uses: actions/cache@v4
        with:
          key: ${{ needs.validate.outputs.prefix }}-${{ matrix.channel }}-${{ needs.download.outputs.version }}
          path: |
            changelog.txt
            arm
            arm64
            mipsbe
            mmips
            ppc
            smips
            tile
            x86

      - name: Unpack NETINSTALL*.TAR.GZ files (1/2)
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name 'netinstall*.tar.gz' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack NETINSTALL*.EXE.ZIP files (1/2)
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name 'netinstall*.exe.zip' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack NETINSTALL*.EXE files
        run: |
          readarray -d '' -t FILES < <(
            find */_netinstall*.exe.zip/* -maxdepth 0 -type f -name '*.exe' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack NETINSTALL*.EXE.ZIP files (2/2)
        run: |
          readarray -d '' -t FILES < <(
            find */_netinstall*.exe.zip/* -maxdepth 0 -type f -name '*.exe' -print0 2>/dev/null || true
          )
          for FILE in "${FILES[@]}"; do
            rm "${FILE}"
            #if [ -d "$(dirname "${FILE}")/_$(basename "${FILE}")" ]; then
            #  mv "$(dirname "${FILE}")/_$(basename "${FILE}")" "/tmp/_$(basename "${FILE}")"
            #  rm -rf "$(dirname "${FILE}")/*"
            #  mv "/tmp/_$(basename "${FILE}")/*" "$(dirname "${FILE}")/"
            #  rm -rf "/tmp/_$(basename "${FILE}")"
            #fi
          done

      - name: Unpack ISO files
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.iso' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            
              README="$(dirname ${FILE})/_$(basename ${FILE})/README.md"
              echo -e "#### Notes:\n- Some NPK files are replaced with symlinks to save space, if their SHA256 hashes match those of NPK files downloaded separately.\n" >> "${README}"
            fi
          done

      - name: Unpack IMG.ZIP files (1/2)
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.img.zip' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              unzip -d "$(dirname "${FILE}")/" "${FILE}" || true
            fi
          done

      - name: Unpack IMG files
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.img' -print0 2>/dev/null || true
            find */_*.iso/* -maxdepth 0 -type f -name '*.img' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack IMG.ZIP files (2/2)
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.img.zip' -print0 2>/dev/null || true
          )
          for FILE in "${FILES[@]}"; do
            if [ -s "${FILE%%.zip}" ]; then
              rm "${FILE%%.zip}"
              if [ -d "$(dirname "${FILE}")/_$(basename "${FILE%%.zip}")" ]; then
                mv "$(dirname "${FILE}")/_$(basename "${FILE%%.zip}")" "$(dirname "${FILE}")/_$(basename "${FILE}")"
              fi
            fi
          done

      - name: Unpack NPK files
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.npk' -print0 2>/dev/null || true
            find */_*.img.zip/loop/* -maxdepth 0 -type f -name '*.npk' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/image -maxdepth 0 -type f -print0 2>/dev/null || true
            find */_*.iso/* -maxdepth 0 -type f -name '*.npk' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              python /tmp/unpack-npk.py "${FILE}" || true
            fi
          done

      - name: Unpack SFS files
        run: |
          readarray -d '' -t FILES < <(
            find */_*.npk/* -maxdepth 0 -type f -name '*.sfs' -print0 2>/dev/null || true
            find */_*.img.zip/loop/_*.npk/* -maxdepth 0 -type f -name '*.sfs' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/_image/* -maxdepth 0 -type f -name '*.sfs' -print0 2>/dev/null || true
            find */_*.iso/_*.npk/* -maxdepth 0 -type f -name '*.sfs' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack JG.GZ files
        run: |
          readarray -d '' -t FILES < <(
            find */_*.npk/_*.sfs/home/web/webfig/* -maxdepth 0 -type f -name '*-*.jg.gz' -print0 2>/dev/null || true
            find */_*.img.zip/loop/_*.npk/_*.sfs/home/web/webfig/* -maxdepth 0 -type f -name '*-*.jg.gz' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/_image/_*.sfs/home/web/webfig/* -maxdepth 0 -type f -name '*-*.jg.gz' -print0 2>/dev/null || true
            find */_*.iso/_*.npk/_*.sfs/home/web/webfig/* -maxdepth 0 -type f -name '*-*.jg.gz' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              mkdir -p "$(dirname "${FILE}")/_$(basename "${FILE}")"
              gzip -cdk < "${FILE}" > "$(dirname "${FILE}")/_$(basename "${FILE}")/$(basename "${FILE%%.gz}")" || true
            fi
          done

      - name: Unpack X3 files
        run: |
          readarray -d '' -t FILES < <(
            find */_*.npk/_*.sfs/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.npk/_*.sfs/bndl/*/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.img.zip/loop/_*.npk/_*.sfs/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.img.zip/loop/_*.npk/_*.sfs/bndl/*/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/_image/_*.sfs/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/_image/_*.sfs/bndl/*/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.iso/_*.npk/_*.sfs/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.iso/_*.npk/_*.sfs/bndl/*/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              echo "DEBUG: unpacking ${FILE}"
              python /tmp/unpack-x3.py "${FILE}" || true
            fi
          done

      - name: Unpack bzImage files
        run: |
          readarray -d '' -t FILES < <(
            find x86/_*.npk/*.files/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.npk/_*.sfs/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.img.zip/loop/* -maxdepth 0 -type f -name "linux" -print0 2>/dev/null || true
            find x86/_*.img.zip/part1/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/_*.sfs/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.iso/_*.img/loop/* -maxdepth 0 -type f -name "linux.*" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/*.files/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/_*.sfs/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack Image and ELF files (1/2)
        run: |
          readarray -d '' -t FILES < <(
            find arm/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find arm64/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part1/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.img/loop/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find mipsbe/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find ppc/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find smips/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find x86/_*.npk/*.files/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.npk/_*.sfs/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.img.zip/loop/_linux/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.img.zip/part1/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/_*.sfs/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.iso/_*.img/loop/_linux.*/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/*.files/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/_*.sfs/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack Image and ELF files (2/2)
        run: |
          readarray -d '' -t FILES < <(
            find arm/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find arm64/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find mipsbe/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find ppc/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find smips/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack RGZ files
        run: |
          readarray -d '' -t FILES < <(
            find tile/_*.npk/*.files/boot/* -maxdepth 0 -type f -name 'initrd.rgz' -print0 2>/dev/null || true
            find tile/_*.npk/_*.sfs/boot/* -maxdepth 0 -type f -name 'initrd.rgz' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack CPIO files
        run: |
          readarray -d '' -t FILES < <(
            find arm/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part1/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.img/loop/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find mipsbe/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find mipsbe/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find ppc/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find ppc/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find smips/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find smips/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/_initrd.rgz/* -maxdepth 0 -type f -name 'initrd' -print0 2>/dev/null || true
            find tile/_*.npk/_*.sfs/boot/_initrd.rgz/* -maxdepth 0 -type f -name 'initrd' -print0 2>/dev/null || true
            find x86/_*.npk/*.files/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.npk/_*.sfs/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.img.zip/loop/_linux/_*.vmlinux/ -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.img.zip/part1/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/_*.sfs/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.iso/_*.img/loop/_linux.*/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/*.files/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/_*.sfs/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack DTB files
        run: |
          readarray -d '' -t FILES < <(
            find arm/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.dtb" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.dtb" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack FWF files
        run: |
          readarray -d '' -t FILES < <(
            find */_*.npk/_*.sfs/etc/* -maxdepth 0 -type f -name "*.fwf" -print0 2>/dev/null || true
            find */_*.iso/_*.npk/_*.sfs/etc/* -maxdepth 0 -type f -name "*.fwf" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              python /tmp/unpack-fwf.py "${FILE}" || true
              
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Remove block and character devices before commit
        run: |
          readarray -d '' -t BLOCKS < <(
            find . -type b -o -type c -print0 2>/dev/null || true
          )
          for BLOCK in "${BLOCKS[@]}"; do
            sudo rm -f "${BLOCK}"
          done

      - name: Fix directory permissions
        run: |
          readarray -d '' -t DIRS < <(
            find . -type d -not -perm 755 -print0 2>/dev/null || true
          )
          for DIR in "${DIRS[@]}"; do
            chmod 755 "${DIR}"
          done

      - name: Put .gitignore into empty directories
        run: |
          readarray -d '' -t DIRS < <(
            find . -type d -empty -print0 2>/dev/null || true
          )
          for DIR in "${DIRS[@]}"; do
            echo -e "*\n!.gitignore\n" > "${DIR}/.gitignore"
          done

      - name: Add files, commit and push
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          branch: ${{ steps.prepare_branch.outputs.BRANCH }}
          create_branch: true
          push_options: '--force'

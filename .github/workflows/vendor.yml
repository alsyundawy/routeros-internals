name: "Vendor RouterOS 7.x Internals Workflow"
run-name: "RouterOS 7.x: [${{ inputs.host }}]-[${{ inputs.prefix }}]-[${{ inputs.channel }}]-[${{ inputs.version }}]-[${{ inputs.scope }}]"
on:
#  push:
#    branches:
#      - main
  workflow_dispatch:
    inputs:
      host:
        description: "Host (e.g., dl.example.com)"
        required: true
        default: 'download.mikrotik.com'
        type: string
      prefix:
        description: "Prefix (e.g., vendor)"
        required: true
        default: 'vendor'
        type: string
      channel:
        description: 'Channel (e.g., stable)'
        required: true
        default: 'stable'
        type: choice
        options:
          - 'stable'
          - 'testing'
          - 'stable,testing'
      version:
        description: "Version (e.g., 7.19.4; empty means latest)"
        required: false
        default: 'latest'
        type: string
      scope:
        description: 'Scope of work (do jobs up to, inclusive)'
        required: true
        default: 'process'
        type: choice
        options:
          - 'validate'
          - 'download'
          - 'process'
      reuse_commits:
        description: "Reuse committed files"
        required: false
        default: true
        type: boolean
      override_cache:
        description: "Override cached files"
        required: false
        default: false
        type: boolean

permissions:
  actions: write
  contents: write

env:
  TZ: 'Europe/London'

jobs:
  validate:
    runs-on: ubuntu-24.04
    outputs:
      host: ${{ steps.validate_host.outputs.host }}
      prefix: ${{ steps.validate_prefix.outputs.prefix }}
      channel: ${{ steps.validate_channel.outputs.channel }}
      version: ${{ steps.validate_version.outputs.version }}
      matrix: ${{ steps.generate_matrix.outputs.matrix }}
      scope: ${{ steps.validate_scope.outputs.scope }}
      scope_has_download: ${{ steps.validate_scope.outputs.download }}
      scope_has_process: ${{ steps.validate_scope.outputs.process }}
    steps:
      - name: Validate host value
        id: validate_host
        run: |
          HOST="$(echo "${{ inputs.host }}" | xargs)"
          if [ -z "$(echo "${HOST}" | grep -P '(?=^.{1,254}$)(^(?>(?!\d+\.)[a-zA-Z0-9_\-]{1,63}\.?)+(?:[a-zA-Z]{2,})$)')" ]; then
            echo "::error input=host,value=${HOST}::Invalid host value"
            exit 1
          fi
          echo "host=${HOST}" >> $GITHUB_OUTPUT

      - name: Validate prefix value
        id: validate_prefix
        run: |
          PREFIX="$(echo "${{ inputs.prefix }}" | xargs)"
          if [ -z "$(echo "${PREFIX}" | grep -P '^[0-9a-zA-Z]+$')" ]; then
            echo "::error input=prefix,value=${PREFIX}::Invalid prefix value"
            exit 1
          fi
          echo "prefix=${PREFIX}" >> $GITHUB_OUTPUT

      - name: Validate channel value
        id: validate_channel
        run: |
          CHANNEL="$(echo "${{ inputs.channel }}" | xargs)"
          readarray -d ',' -t CHANNELS < <(printf '%s' "${CHANNEL}")
          for CHANNEL in ${CHANNELS[@]}; do
            if [ "${CHANNEL}" != "stable" -a "${CHANNEL}" != "testing" ]; then
              echo "::error input=channel,value=${CHANNEL}::Invalid channel value"
              exit 1
            fi
          done
          printf -v CHANNEL '%s,' "${CHANNELS[@]}"
          echo "channel=${CHANNEL%,}" >> $GITHUB_OUTPUT

      - name: Validate version value
        id: validate_version
        run: |
          VERSION="$(echo "${{ inputs.version }}" | xargs)"
          CHANNEL="$(echo "${{ steps.validate_channel.outputs.channel }}" | xargs)"
          if [ -n "${VERSION}" -a "${VERSION}" != "latest" ]; then
            if [ -n "$(echo "${CHANNEL}" | grep ',')" ]; then
              echo "::error input=version,value=${VERSION}::Same version value can't apply to multiple channels"
              exit 1
            elif [ "${CHANNEL}" == "stable" ]; then
              if [ -z "$(echo "${VERSION}" | grep -P '^7\.[0-9]+(\.[0-9]+)?$')" ]; then
                echo "::error input=version,value=${VERSION}::Invalid version value for the ${CHANNEL} channel"
                exit 1
              fi
            elif [ "${CHANNEL}" == "testing" ]; then
              if [ -z "$(echo "${VERSION}" | grep -P '^7\.[0-9]+(\.[0-9]+)?(ab|beta|rc)[0-9]+$')" ]; then
                echo "::error input=version,value=${VERSION}::Invalid version value for the ${CHANNEL} channel"
                exit 1
              fi
            else
              echo "::warning::Unknown channel value, so version value has not been validated"
            fi
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Generate matrix using channel and version values
        id: generate_matrix
        run: |
          readarray -d ',' -t CHANNELS < <(printf '%s' "${{ steps.validate_channel.outputs.channel }}")
          VERSION="${{ steps.validate_version.outputs.version }}"
          JSON=""
          for CHANNEL in ${CHANNELS[@]}; do
            if [ -z "${VERSION}" -o "${VERSION}" == "latest" ]; then
              FILE="version_${CHANNEL}.txt"
              URL="https://${{ steps.validate_host.outputs.host }}/routeros/NEWESTa7.${CHANNEL}"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
              if [ ! -f "${FILE}" ]; then
                echo "::error::Failed to get the latest version for the ${CHANNEL} channel"
                exit 1
              fi
              LATEST="$(cat ${FILE} | cut -d ' ' -f1)" && rm -f "${FILE}"
            else
              LATEST="${VERSION}"
            fi
            [ ${#JSON} -ne 0 ] && JSON="${JSON},"
            JSON="${JSON}{\"channel\":\"${CHANNEL}\",\"version\":\"${LATEST}\"}"
          done
          JSON="[${JSON}]"
          echo "matrix=${JSON}" >> $GITHUB_OUTPUT

      - name: Validate scope value
        id: validate_scope
        run: |
          SCOPE="$(echo "${{ inputs.scope }}" | xargs)"
          if [ "${SCOPE}" == "validate" ]; then
            DOWNLOAD=false
            PROCESS=false
          elif [ "${SCOPE}" == "download" ]; then
            DOWNLOAD=true
            PROCESS=false
          elif [ "${SCOPE}" == "process" ]; then
            DOWNLOAD=true
            PROCESS=true
          else
            echo "::error input=scope,value=${SCOPE}::Invalid scope value"
            exit 1
          fi
          echo "scope=${SCOPE%,}" >> $GITHUB_OUTPUT
          echo "download=${DOWNLOAD}" >> $GITHUB_OUTPUT
          echo "process=${PROCESS}" >> $GITHUB_OUTPUT

      - name: Compose a step summary
        id: compose_summary
        run: |
          {
            echo "### Outputs"
            echo "- host: \`${{ steps.validate_host.outputs.host }}\`"
            echo "- prefix: \`${{ steps.validate_prefix.outputs.prefix }}\`"
            echo "- channel: \`${{ steps.validate_channel.outputs.channel }}\`"
            echo "- version: \`${{ steps.validate_version.outputs.version }}\`"
            echo "- matrix: \`${{ steps.generate_matrix.outputs.matrix }}\`"
            echo "- scope: \`${{ steps.validate_scope.outputs.scope }}\`"
            echo "- scope_has_download: \`${{ steps.validate_scope.outputs.download }}\`"
            echo "- scope_has_process: \`${{ steps.validate_scope.outputs.process }}\`"
          } >> $GITHUB_STEP_SUMMARY

  download:
    if: needs.validate.outputs.scope_has_download == 'true'
    needs: validate
    runs-on: ubuntu-24.04
    strategy:
      matrix:
        include: ${{ fromJSON(needs.validate.outputs.matrix) }}
    steps:
      - name: Checkout the repository
        id: checkout_repository
        uses: actions/checkout@v5

      - name: Generate a branch ref
        id: generate_ref
        run: |
          REF="${{ needs.validate.outputs.prefix }}-${{ matrix.channel }}-${{ matrix.version }}"
          echo "ref=${REF}" >> $GITHUB_OUTPUT

      - name: Prepare a branch
        id: prepare_branch
        run: |
          BRANCH="${{ steps.generate_ref.outputs.ref }}"
          if [ -z "$(git ls-remote --heads origin ${BRANCH})" -o "${{ inputs.override_cache }}" == "true" ]; then
            git switch --orphan ${BRANCH}
            echo "new=true" >> $GITHUB_OUTPUT
          else
            echo "new=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate download urls
        id: generate_urls
        if: steps.prepare_branch.outputs.new == 'true'
        run: |
          BRANCH="${{ steps.generate_ref.outputs.ref }}"
          echo "github=https://github.com/${{ github.repository }}/raw/refs/heads/${BRANCH}" >> $GITHUB_OUTPUT
          echo "vendor=https://${{ needs.validate.outputs.host }}/routeros/${{ matrix.version }}" >> $GITHUB_OUTPUT

#      - name: Restore files from cache
#        id: restore_files
#        uses: actions/cache/restore@v4
#        with:
#          key: ${{ steps.generate_ref.outputs.ref }}
#          lookup-only: true
#          path: |
#            changelog.txt
#            */*.iso
#            */*.npk
#            */*.tar.gz
#            */*.zip

      - name: Download a changelog
        id: download_changelog
        if: steps.prepare_branch.outputs.new == 'true'
        run: |
          FILE="changelog.txt"
          if [ "${{ inputs.reuse_commits }}" == "true" ]; then
            URL="${{ steps.generate_urls.outputs.github }}/${FILE}"
            wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
          fi
          if [ ! -f "${FILE}" ]; then
            URL="${{ steps.generate_urls.outputs.vendor }}/CHANGELOG"
            wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
          fi

      - name: Download packages
        id: download_packages
        if: steps.prepare_branch.outputs.new == 'true'
        run: |
          ARCHS=(arm arm64 mipsbe mmips ppc smips tile x86)
          PACKAGES=(routeros)
          VERSION="${{ matrix.version }}"
          for ARCH in ${ARCHS[@]}; do
            mkdir -p ${ARCH}
            [ "${ARCH}" == 'x86' ] && SUFFIX='' || SUFFIX="-${ARCH}"
            
            for PACKAGE in ${PACKAGES[@]}; do
              FILE="${ARCH}/${PACKAGE}-${VERSION}${SUFFIX}.npk"
              if [ "${{ inputs.reuse_commits }}" == "true" ]; then
                URL="${{ steps.generate_urls.outputs.github }}/${FILE}"
                wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
              fi
              if [ ! -f "${FILE}" ]; then
                URL="${{ steps.generate_urls.outputs.vendor }}/${PACKAGE}-${VERSION}${SUFFIX}.npk"
                wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
              fi
            done
            
            FILE="${ARCH}/all_packages-${VERSION}${SUFFIX}.zip"
            URL="${{ steps.generate_urls.outputs.vendor }}/all_packages-${ARCH}-${VERSION}.zip"
            wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            if [ -f "${FILE}" ]; then
              unzip -o -d "${ARCH}/" "${FILE}" && rm -f ${FILE}
            fi
          done

      - name: Download images
        id: download_images
        if: steps.prepare_branch.outputs.new == 'true'
        run: |
          ARCHS=(arm64 x86)
          VERSION="${{ matrix.version }}"
          for ARCH in ${ARCHS[@]}; do
            mkdir -p ${ARCH}
            [ "${ARCH}" == 'x86' ] && SUFFIX='' || SUFFIX="-${ARCH}"
            
            FILE="${ARCH}/chr-${VERSION}${SUFFIX}.img.zip"
            if [ "${{ inputs.reuse_commits }}" == "true" ]; then
              URL="${{ steps.generate_urls.outputs.github }}/${FILE}"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            if [ ! -f "${FILE}" ]; then
              URL="${{ steps.generate_urls.outputs.vendor }}/chr-${VERSION}${SUFFIX}.img.zip"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            
            FILE="${ARCH}/mikrotik-${VERSION}${SUFFIX}.iso"
            if [ "${{ inputs.reuse_commits }}" == "true" ]; then
              URL="${{ steps.generate_urls.outputs.github }}/${FILE}"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            if [ ! -f "${FILE}" ]; then
              URL="${{ steps.generate_urls.outputs.vendor }}/mikrotik-${VERSION}${SUFFIX}.iso"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            
            if [ "${ARCH}" == 'x86' ]; then
              FILE="${ARCH}/install-image-${VERSION}${SUFFIX}.img.zip"
              if [ "${{ inputs.reuse_commits }}" == "true" ]; then
                URL="${{ steps.generate_urls.outputs.github }}/${FILE}"
                wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
              fi
              if [ ! -f "${FILE}" ]; then
                URL="${{ steps.generate_urls.outputs.vendor }}/install-image-${VERSION}${SUFFIX}.zip"
                wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
              fi
            fi
          done

      - name: Download binaries
        id: download_binaries
        if: steps.prepare_branch.outputs.new == 'true'
        run: |
          ARCHS=(x86)
          VERSION="${{ matrix.version }}"
          for ARCH in ${ARCHS[@]}; do
            mkdir -p ${ARCH}
            [ "${ARCH}" == 'x86' ] && SUFFIX='' || SUFFIX="-${ARCH}"
            
            FILE="${ARCH}/netinstall-cli-${VERSION}${SUFFIX}.tar.gz"
            if [ "${{ inputs.reuse_commits }}" == "true" ]; then
              URL="${{ steps.generate_urls.outputs.github }}/${FILE}"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            if [ ! -f "${FILE}" ]; then
              URL="${{ steps.generate_urls.outputs.vendor }}/netinstall-${VERSION}${SUFFIX}.tar.gz"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            
            FILE="${ARCH}/netinstall-w32-${VERSION}${SUFFIX}.exe.zip"
            if [ "${{ inputs.reuse_commits }}" == "true" ]; then
              URL="${{ steps.generate_urls.outputs.github }}/${FILE}"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            if [ ! -f "${FILE}" ]; then
              URL="${{ steps.generate_urls.outputs.vendor }}/netinstall-${VERSION}${SUFFIX}.zip"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            
            FILE="${ARCH}/netinstall-w64-${VERSION}${SUFFIX}.exe.zip"
            if [ "${{ inputs.reuse_commits }}" == "true" ]; then
              URL="${{ steps.generate_urls.outputs.github }}/${FILE}"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
            if [ ! -f "${FILE}" ]; then
              URL="${{ steps.generate_urls.outputs.vendor }}/netinstall64-${VERSION}${SUFFIX}.zip"
              wget -nv -O ${FILE} ${URL} || rm -f ${FILE}
            fi
          done

#      - name: Delete files from cache
#        id: delete_files
#        if: inputs.override_cache
#        env:
#          GH_TOKEN: ${{ github.token }}
#        run: |
#          # Note: actions:write permission is required
#          gh api --method DELETE \
#            -H "Accept: application/vnd.github+json" \
#            -H "X-GitHub-Api-Version: 2022-11-28" \
#            /repos/${{ github.repository }}/actions/caches?key=${{ steps.generate_ref.outputs.ref }}&ref=${{ github.ref }}

#      - name: Save files to cache
#        id: save_files
#        if: inputs.override_cache || steps.restore_files.outputs.cache-hit != 'true'
#        uses: actions/cache/save@v4
#        with:
#          key: ${{ steps.generate_ref.outputs.ref }}
#          path: |
#            changelog.txt
#            */*.iso
#            */*.npk
#            */*.tar.gz
#            */*.zip

      - name: Compose a commit message
        id: compose_message
        if: steps.prepare_branch.outputs.new == 'true'
        run: |
          {
            echo 'message<<EOF'
            echo -e "Automatic changes by ${{ github.run_id }}:${{ github.run_attempt }}:download\n\n"
            echo -e "Job https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/job/${{ github.job }}"
            echo -e "Run https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/attempts/${{ github.run_attempt }}"
            echo EOF
          } >> $GITHUB_OUTPUT

      - name: Add files, commit and push
        id: push_files
        if: steps.prepare_branch.outputs.new == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          branch: ${{ steps.generate_ref.outputs.ref }}
          commit_message: ${{ steps.compose_message.outputs.message }}
          create_branch: true
          push_options: '--force'

  process:
    if: needs.validate.outputs.scope_has_process == 'true'
    needs:
      - validate
      - download
    runs-on: ubuntu-24.04
    strategy:
      matrix:
        include: ${{ fromJSON(needs.validate.outputs.matrix) }}
    steps:
      - name: Install requirements leveraging cache
        id: install_requirements
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          execute_install_scripts: true
          packages: binutils-common binwalk bzip2 device-tree-compiler genisoimage gzip lz4 lzma lzop qemu-utils rsync xz-utils zip zstd
          version: 1.0

      - name: Checkout the main branch
        id: checkout_main
        uses: actions/checkout@v5

      - name: Copy executable files
        id: copy_files
        run: |
          cp -r ./tools /tmp/
          cp ./*.py /tmp/
          cp ./*.sh /tmp/
          chmod +x /tmp/*.sh

      - name: Generate a branch ref
        id: generate_ref
        run: |
          REF="${{ needs.validate.outputs.prefix }}-${{ matrix.channel }}-${{ matrix.version }}"
          echo "ref=${REF}" >> $GITHUB_OUTPUT

      - name: Checkout the current branch
        id: checkout_branch
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.generate_ref.outputs.ref }}

#      - name: Prepare a branch
#        id: prepare_branch
#        run: |
#          BRANCH="${{ steps.generate_ref.outputs.ref }}"
#          if [ -z "$(git ls-remote --heads origin ${BRANCH})" ]; then
#            echo "::error::Nothing to process because the branch can't be found"
#            exit 1
#          fi
#          git fetch --depth=1 origin ${BRANCH}
#
#          COMMITS="$(git log ${BRANCH} --oneline)"
#
#          FIRST="$(echo "${COMMITS}" | tail -1 | cut -d ' ' -f1)"
#          LAST="$(echo "${COMMITS}" | head -1 | cut -d ' ' -f1)"
#          if [ -z "${FIRST}" -o -z "${LAST}" ]; then
#            echo "::error::Nothing to process because the first and the last commits can't be identified"
#            exit 1
#          fi
#          git checkout ${BRANCH}
#
#          echo "first=${FIRST}" >> $GITHUB_OUTPUT
#          echo "last=${LAST}" >> $GITHUB_OUTPUT

#      - name: Restore files from cache
#        id: restore_files
#        uses: actions/cache/restore@v4
#        with:
#          key: ${{ steps.generate_ref.outputs.ref }}
#          path: |
#            changelog.txt
#            */*.iso
#            */*.npk
#            */*.tar.gz
#            */*.zip

      - name: Remove unpacked files if any
        id: remove_files
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -print0 2>/dev/null || true
          )
          for FILE in "${FILES[@]}"; do
            DIR="$(dirname "${FILE}")/_$(basename "${FILE}")"
            if [ -d "${DIR}" ]; then
              rm -rf "${DIR}"
            fi
          done
          rm -f 'hashes.txt'
          rm -f 'replacements.txt'

      - name: Unpack NETINSTALL*.TAR.GZ files (1/2)
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name 'netinstall*.tar.gz' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack NETINSTALL*.EXE.ZIP files (1/2)
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name 'netinstall*.exe.zip' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack NETINSTALL*.EXE files
        run: |
          readarray -d '' -t FILES < <(
            find */_netinstall*.exe.zip/* -maxdepth 0 -type f -name '*.exe' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack NETINSTALL*.EXE.ZIP files (2/2)
        run: |
          readarray -d '' -t FILES < <(
            find */_netinstall*.exe.zip/* -maxdepth 0 -type f -name '*.exe' -print0 2>/dev/null || true
          )
          for FILE in "${FILES[@]}"; do
            rm "${FILE}"
            #if [ -d "$(dirname "${FILE}")/_$(basename "${FILE}")" ]; then
            #  mv "$(dirname "${FILE}")/_$(basename "${FILE}")" "/tmp/_$(basename "${FILE}")"
            #  rm -rf "$(dirname "${FILE}")/*"
            #  mv "/tmp/_$(basename "${FILE}")/*" "$(dirname "${FILE}")/"
            #  rm -rf "/tmp/_$(basename "${FILE}")"
            #fi
          done

      - name: Unpack ISO files
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.iso' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            
              README="$(dirname ${FILE})/_$(basename ${FILE})/README.md"
              echo -e "#### Notes:\n- Some NPK files are replaced with symlinks to save space, if their SHA256 hashes match those of NPK files downloaded separately.\n" >> "${README}"
            fi
          done

      - name: Unpack IMG.ZIP files (1/2)
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.img.zip' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              unzip -d "$(dirname "${FILE}")/" "${FILE}" || true
            fi
          done

      - name: Unpack IMG files
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.img' -print0 2>/dev/null || true
            find */_*.iso/* -maxdepth 0 -type f -name '*.img' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack IMG.ZIP files (2/2)
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.img.zip' -print0 2>/dev/null || true
          )
          for FILE in "${FILES[@]}"; do
            if [ -s "${FILE%%.zip}" ]; then
              rm "${FILE%%.zip}"
              if [ -d "$(dirname "${FILE}")/_$(basename "${FILE%%.zip}")" ]; then
                mv "$(dirname "${FILE}")/_$(basename "${FILE%%.zip}")" "$(dirname "${FILE}")/_$(basename "${FILE}")"
              fi
            fi
          done

      - name: Unpack NPK files
        run: |
          readarray -d '' -t FILES < <(
            find */* -maxdepth 0 -type f -name '*.npk' -print0 2>/dev/null || true
            find */_*.img.zip/loop/* -maxdepth 0 -type f -name '*.npk' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/image -maxdepth 0 -type f -print0 2>/dev/null || true
            find */_*.iso/* -maxdepth 0 -type f -name '*.npk' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              python /tmp/unpack-npk.py "${FILE}" || true
            fi
          done

      - name: Unpack SFS files
        run: |
          readarray -d '' -t FILES < <(
            find */_*.npk/* -maxdepth 0 -type f -name '*.sfs' -print0 2>/dev/null || true
            find */_*.img.zip/loop/_*.npk/* -maxdepth 0 -type f -name '*.sfs' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/_image/* -maxdepth 0 -type f -name '*.sfs' -print0 2>/dev/null || true
            find */_*.iso/_*.npk/* -maxdepth 0 -type f -name '*.sfs' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack JG.GZ files
        run: |
          readarray -d '' -t FILES < <(
            find */_*.npk/_*.sfs/home/web/webfig/* -maxdepth 0 -type f -name '*-*.jg.gz' -print0 2>/dev/null || true
            find */_*.img.zip/loop/_*.npk/_*.sfs/home/web/webfig/* -maxdepth 0 -type f -name '*-*.jg.gz' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/_image/_*.sfs/home/web/webfig/* -maxdepth 0 -type f -name '*-*.jg.gz' -print0 2>/dev/null || true
            find */_*.iso/_*.npk/_*.sfs/home/web/webfig/* -maxdepth 0 -type f -name '*-*.jg.gz' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              mkdir -p "$(dirname "${FILE}")/_$(basename "${FILE}")"
              gzip -cdk < "${FILE}" > "$(dirname "${FILE}")/_$(basename "${FILE}")/$(basename "${FILE%%.gz}")" || true
            fi
          done

      - name: Unpack X3 files
        run: |
          readarray -d '' -t FILES < <(
            find */_*.npk/_*.sfs/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.npk/_*.sfs/bndl/*/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.img.zip/loop/_*.npk/_*.sfs/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.img.zip/loop/_*.npk/_*.sfs/bndl/*/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/_image/_*.sfs/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.img.zip/part2/var/pdb/*/_image/_*.sfs/bndl/*/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.iso/_*.npk/_*.sfs/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
            find */_*.iso/_*.npk/_*.sfs/bndl/*/nova/etc/*/* -maxdepth 0 -type f -name '*.x3' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              echo "DEBUG: unpacking ${FILE}"
              python /tmp/unpack-x3.py "${FILE}" || true
            fi
          done

      - name: Unpack bzImage files
        run: |
          readarray -d '' -t FILES < <(
            find x86/_*.npk/*.files/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.npk/_*.sfs/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.img.zip/loop/* -maxdepth 0 -type f -name "linux" -print0 2>/dev/null || true
            find x86/_*.img.zip/part1/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/_*.sfs/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.iso/_*.img/loop/* -maxdepth 0 -type f -name "linux.*" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/*.files/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/_*.sfs/boot/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack Image and ELF files (1/2)
        run: |
          readarray -d '' -t FILES < <(
            find arm/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find arm64/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part1/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.img/loop/EFI/BOOT/* -maxdepth 0 -type f -name "*.EFI" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find mipsbe/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find ppc/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find smips/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/* -maxdepth 0 -type f -name "kernel" -print0 2>/dev/null || true
            find x86/_*.npk/*.files/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.npk/_*.sfs/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.img.zip/loop/_linux/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.img.zip/part1/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/_*.sfs/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.iso/_*.img/loop/_linux.*/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/*.files/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/_*.sfs/boot/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack Image and ELF files (2/2)
        run: |
          readarray -d '' -t FILES < <(
            find arm/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find arm64/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find mipsbe/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find ppc/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find smips/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.vmlinux" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack RGZ files
        run: |
          readarray -d '' -t FILES < <(
            find tile/_*.npk/*.files/boot/* -maxdepth 0 -type f -name 'initrd.rgz' -print0 2>/dev/null || true
            find tile/_*.npk/_*.sfs/boot/* -maxdepth 0 -type f -name 'initrd.rgz' -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack CPIO files
        run: |
          readarray -d '' -t FILES < <(
            find arm/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part1/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.img/loop/EFI/BOOT/_*.EFI/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find arm64/_*.iso/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find mipsbe/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find mipsbe/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find ppc/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find ppc/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find smips/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find smips/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/_kernel/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find tile/_*.npk/*.files/boot/_initrd.rgz/* -maxdepth 0 -type f -name 'initrd' -print0 2>/dev/null || true
            find tile/_*.npk/_*.sfs/boot/_initrd.rgz/* -maxdepth 0 -type f -name 'initrd' -print0 2>/dev/null || true
            find x86/_*.npk/*.files/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.npk/_*.sfs/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.img.zip/loop/_linux/_*.vmlinux/ -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.img.zip/part1/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/*.files/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.img.zip/part2/var/pdb/*/_image/_*.sfs/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.iso/_*.img/loop/_linux.*/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/*.files/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
            find x86/_*.iso/_*.npk/_*.sfs/boot/EFI/BOOT/_*.EFI/_*.vmlinux/* -maxdepth 0 -type f -name "*.cpio" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack DTB files
        run: |
          readarray -d '' -t FILES < <(
            find arm/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.dtb" -print0 2>/dev/null || true
            find mmips/_*.npk/*.files/boot/_kernel/_*.vmlinux/* -maxdepth 0 -type f -name "*.dtb" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              sudo /tmp/unpack.sh "${FILE}" || true
          
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Unpack FWF files
        run: |
          readarray -d '' -t FILES < <(
            find */_*.npk/_*.sfs/etc/* -maxdepth 0 -type f -name "*.fwf" -print0 2>/dev/null || true
            find */_*.iso/_*.npk/_*.sfs/etc/* -maxdepth 0 -type f -name "*.fwf" -print0 2>/dev/null || true
          )
          declare -A HASHES
          for FILE in "${FILES[@]}"; do
            HASH="$(sha256sum "${FILE}" | gawk '{ print $1 }')"
            if [ -n "${HASHES[${HASH}]}" ]; then
              ln -sfr "${HASHES[${HASH}]}" "${FILE}"
              echo -e "${FILE} $(realpath --relative-to='.' "${HASHES[${HASH}]}")" >> 'replacements.txt'
            else
              HASHES[${HASH}]="$(realpath "${FILE}")"
              echo -e "${HASH} ${FILE}" >> 'hashes.txt'
              python /tmp/unpack-fwf.py "${FILE}" || true
              
              if [ -d "$(dirname ${FILE})/_$(basename ${FILE})" ]; then
                sudo chown -hR $(id -un):$(id -gn) "$(dirname ${FILE})/_$(basename ${FILE})"
              fi
            fi
          done

      - name: Remove block and character devices before commit
        run: |
          readarray -d '' -t BLOCKS < <(
            find . -type b -o -type c -print0 2>/dev/null || true
          )
          for BLOCK in "${BLOCKS[@]}"; do
            sudo rm -f "${BLOCK}"
          done

      - name: Fix directory permissions
        run: |
          readarray -d '' -t DIRS < <(
            find . -type d -not -perm 755 -print0 2>/dev/null || true
          )
          for DIR in "${DIRS[@]}"; do
            chmod 755 "${DIR}"
          done

      - name: Put .gitignore into empty directories
        run: |
          readarray -d '' -t DIRS < <(
            find . -type d -empty -print0 2>/dev/null || true
          )
          for DIR in "${DIRS[@]}"; do
            echo -e "*\n!.gitignore\n" > "${DIR}/.gitignore"
          done

      - name: Compose a commit message
        id: compose_message
        run: |
          {
            echo 'message<<EOF'
            echo -e "Automatic changes by ${{ github.run_id }}:${{ github.run_attempt }}:process\n\n"
            echo -e "Job https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/job/${{ github.job }}"
            echo -e "Run https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/attempts/${{ github.run_attempt }}"
            echo EOF
          } >> $GITHUB_OUTPUT

      - name: Add files, commit and push
        uses: stefanzweifel/git-auto-commit-action@v6
        with:
          branch: ${{ steps.generate_ref.outputs.ref }}
          commit_message: ${{ steps.compose_message.outputs.message }}
          push_options: '--force'
